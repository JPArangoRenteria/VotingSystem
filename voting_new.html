<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <title>Voting System Simulator — Enhanced</title>
  <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.min.js"></script>
  <style>
    body { font-family: system-ui, Arial; margin: 20px; background:#f6f8fa; color:#111; }
    h1, h2 { text-align:center; margin: .5rem 0; }
    .container { display:flex; flex-wrap:wrap; gap:20px; justify-content:center; }
    .box { background:#fff; padding:16px; border-radius:8px; box-shadow:0 6px 18px rgba(22,27,34,.06); flex:1 1 320px; max-width:520px; }
    label { display:block; margin:8px 0; font-size:14px; }
    input[type=number], select, input[type=text] { width:100%; padding:8px; box-sizing:border-box; margin-top:6px; }
    button { padding:10px 14px; margin-top:10px; cursor:pointer; }
    #results-list { max-height:240px; overflow:auto; padding-left:16px; margin:0; }
    #charts { max-width:1000px; margin:20px auto; }
    .flex-row { display:flex; gap:8px; align-items:center; }
    .muted { color:#666; font-size:13px; }
    .progress { width:100%; background:#eee; height:14px; border-radius:8px; overflow:hidden; margin-top:8px; }
    .progress > div { height:100%; background:linear-gradient(90deg,#4f46e5,#06b6d4); width:0%; transition:width .2s; }
    table { width:100%; border-collapse:collapse; font-size:13px; }
    th,td { padding:8px 6px; border-bottom:1px solid #f1f1f1; text-align:left; }
    .small { font-size:13px; }
  </style>
</head>
<body>
  <h1>Voting System Simulator — Enhanced</h1>

  <div class="container">
    <div class="box" aria-labelledby="controls-heading">
      <h2 id="controls-heading">Simulation Controls</h2>
      <label>Number of Voters:
        <input type="number" id="numVoters" min="1" value="100">
      </label>
      <label>Number of Candidates:
        <input type="number" id="numCandidates" min="2" value="4">
      </label>
      <label>Number of Simulations:
        <input type="number" id="numSimulations" min="1" value="20">
      </label>

      <label>Voter Model:
        <select id="voterModel">
          <option value="impartial">Impartial culture (random rankings)</option>
          <option value="single-peaked">Single-peaked (1D ideology)</option>
        </select>
      </label>

      <label>Random Seed (empty=random):
        <input type="text" id="seed" placeholder="e.g. 12345">
      </label>

      <label>Approval threshold (top k for approval):
        <input type="number" id="approvalK" min="1" value="2">
      </label>

      <div class="flex-row">
        <button id="runBtn">Run Simulation</button>
        <button id="exportCsvBtn">Export CSV</button>
      </div>

      <div id="runStatus" class="muted small" aria-live="polite">Idle</div>
      <div class="progress" title="Simulation progress" aria-hidden="false">
        <div id="progressBar"></div>
      </div>
    </div>

    <div class="box">
      <h2>Summary Statistics</h2>
      <div id="summary-content">No simulations yet.</div>
      <h3 class="small">Per-method candidate wins</h3>
      <div id="table-wrapper" style="overflow:auto; max-height:260px;"></div>
    </div>

    <div class="box">
      <h2>Individual Simulation Results</h2>
      <ul id="results-list" aria-live="polite"></ul>
    </div>
  </div>

  <div id="charts">
    <h2>Comparison Charts</h2>
    <canvas id="comparisonChart" style="max-width:960px; margin:0 auto; display:block;"></canvas>
  </div>

<script>
/* =======================
   Utilities & RNG
   ======================= */
function mulberry32(a) {
  return function() {
    let t = a += 0x6D2B79F5;
    t = Math.imul(t ^ t >>> 15, t | 1);
    t ^= t + Math.imul(t ^ t >>> 7, t | 61);
    return ((t ^ t >>> 14) >>> 0) / 4294967296;
  }
}
function seededRNG(seedText) {
  if (seedText === "" || seedText == null) return Math.random;
  // simple hash of seedText to 32-bit int
  let h = 2166136261 >>> 0;
  for (let i = 0; i < seedText.length; i++) {
    h ^= seedText.charCodeAt(i);
    h += (h << 1) + (h << 4) + (h << 7) + (h << 8) + (h << 24);
  }
  return mulberry32(h >>> 0);
}
function shuffleArray(arr, rand=Math.random) {
  for (let i = arr.length - 1; i > 0; i--) {
    const j = Math.floor(rand() * (i + 1));
    [arr[i], arr[j]] = [arr[j], arr[i]];
  }
}

/* =======================
   Preference generation
   ======================= */
function generateBallots(voters, candidates, model='impartial', rng=Math.random) {
  const ballots = [];
  if (model === 'impartial') {
    for (let i = 0; i < voters; i++) {
      const ballot = [...Array(candidates).keys()];
      shuffleArray(ballot, rng);
      ballots.push(ballot);
    }
  } else if (model === 'single-peaked') {
    // generate positions in [0,1] for candidates and voters
    const candPos = Array.from({length: candidates}, () => rng());
    const voterPos = Array.from({length: voters}, () => rng());
    for (let v = 0; v < voters; v++) {
      const p = voterPos[v];
      const order = candPos.map((pos, idx) => ({idx, dist: Math.abs(pos - p)}))
                          .sort((a,b) => a.dist - b.dist)
                          .map(o => o.idx);
      ballots.push(order);
    }
  }
  return ballots;
}

/* =======================
   Voting methods
   All ballot inputs are arrays where ballot[0] is top-ranked.
   For Score and Approval we simulate conversions from ranking here.
   ======================= */
function plurality(ballots) {
  if (!ballots.length) return null;
  const n = ballots[0].length;
  const scores = new Array(n).fill(0);
  ballots.forEach(b => scores[b[0]]++);
  return argMax(scores);
}

function bordaCount(ballots) {
  if (!ballots.length) return null;
  const n = ballots[0].length;
  const scores = new Array(n).fill(0);
  ballots.forEach(b => {
    b.forEach((candidate, index) => {
      scores[candidate] += (n - index - 1);
    });
  });
  return argMax(scores);
}

function instantRunoff(ballots) {
  if (!ballots.length) return null;
  let candidates = [...Array(ballots[0].length).keys()];
  let votes = ballots.map(b => b.slice()); // copy
  while (candidates.length > 1) {
    const counts = Object.fromEntries(candidates.map(c => [c, 0]));
    votes.forEach(v => {
      // pick first preference that is still in candidates
      const pref = v.find(p => candidates.includes(p));
      if (pref !== undefined) counts[pref]++;
    });
    const total = Object.values(counts).reduce((a,b)=>a+b,0);
    for (const c of candidates) {
      if (counts[c] > total/2) return c;
    }
    // eliminate candidate(s) with min votes
    const minVotes = Math.min(...Object.values(counts));
    const losers = Object.keys(counts).filter(k => counts[k] === minVotes).map(Number);
    // tie-break: remove all tied minima simultaneously (simple approach)
    candidates = candidates.filter(c => !losers.includes(c));
    if (candidates.length === 0) return losers[0]; // degenerate case
  }
  return candidates[0];
}

function approvalVoting(ballots, k=1) {
  if (!ballots.length) return null;
  const n = ballots[0].length;
  const scores = new Array(n).fill(0);
  ballots.forEach(b => {
    // approve top-k
    for (let i = 0; i < Math.min(k, b.length); i++) scores[b[i]]++;
  });
  return argMax(scores);
}

function scoreVoting(ballots, maxScore=5) {
  // derive scores from ranking: top gets maxScore, next gets maxScore-1, etc.
  if (!ballots.length) return null;
  const n = ballots[0].length;
  const scores = new Array(n).fill(0);
  ballots.forEach(b => {
    b.forEach((candidate, idx) => {
      const s = Math.max(0, maxScore - idx); // descending
      scores[candidate] += s;
    });
  });
  return argMax(scores);
}

function condorcetWinner(ballots) {
  if (!ballots.length) return null;
  const n = ballots[0].length;
  // pairwise matrix: pairWins[a][b] = number of voters preferring a over b
  const pairWins = Array.from({length: n}, () => new Array(n).fill(0));
  ballots.forEach(b => {
    for (let i = 0; i < n; i++) {
      for (let j = i+1; j < n; j++) {
        const a = b[i], bb = b[j];
        pairWins[a][bb] += 1;
      }
    }
  });
  for (let a = 0; a < n; a++) {
    let winsAll = true;
    for (let b = 0; b < n; b++) {
      if (a === b) continue;
      if (pairWins[a][b] <= pairWins[b][a]) { winsAll = false; break; }
    }
    if (winsAll) return a;
  }
  return null;
}

/* =======================
   Helpers
   ======================= */
function argMax(arr) {
  let best = 0;
  for (let i = 1; i < arr.length; i++) if (arr[i] > arr[best]) best = i;
  return best;
}

/* =======================
   UI & Simulation orchestration
   ======================= */
const results = []; // {sim, method, winner}
let chart; // Chart.js
const methods = [
  {id:'Plurality', fn: plurality},
  {id:'Borda', fn: bordaCount},
  {id:'IRV', fn: instantRunoff},
  {id:'Approval', fn: (b, opts) => approvalVoting(b, opts.approvalK)},
  {id:'Score', fn: (b, opts) => scoreVoting(b, 5)},
  {id:'Condorcet', fn: condorcetWinner}
];

function resetUI() {
  document.getElementById('results-list').innerHTML = '';
  document.getElementById('summary-content').innerHTML = 'No simulations yet.';
  document.getElementById('table-wrapper').innerHTML = '';
  if (chart) { chart.destroy(); chart = null; }
}

function updateProgress(pct, text) {
  document.getElementById('progressBar').style.width = `${pct}%`;
  document.getElementById('runStatus').textContent = text || '';
}

function renderTable(winCounts, candidateLabels) {
  // winCounts: {method: [count per candidate]}
  const methodsKeys = Object.keys(winCounts);
  const n = candidateLabels.length;
  let html = '<table><thead><tr><th>Method</th>';
  for (let i=0;i<n;i++) html += `<th>Candidate ${candidateLabels[i]}</th>`;
  html += '</tr></thead><tbody>';
  for (const m of methodsKeys) {
    html += `<tr><td>${m}</td>`;
    for (let i=0;i<n;i++) html += `<td>${winCounts[m][i] || 0}</td>`;
    html += '</tr>';
  }
  html += '</tbody></table>';
  document.getElementById('table-wrapper').innerHTML = html;
}

function renderChart(winCounts, candidateLabels) {
  // Build datasets: one per candidate, x labels are methods
  const methodLabels = Object.keys(winCounts);
  const n = candidateLabels.length;
  const datasets = candidateLabels.map((label, idx) => {
    const data = methodLabels.map(m => (winCounts[m][idx] || 0));
    const hue = (idx * 360 / Math.max(1,n)).toFixed(0);
    return {
      label: `Candidate ${label}`,
      data,
      backgroundColor: `hsl(${hue} 70% 55% / 0.9)`
    };
  });
  const ctx = document.getElementById('comparisonChart').getContext('2d');
  if (chart) chart.destroy();
  chart = new Chart(ctx, {
    type: 'bar',
    data: { labels: methodLabels, datasets },
    options: { responsive:true, plugins:{legend:{position:'bottom'}} }
  });
}

function exportCSV() {
  if (results.length === 0) { alert('No results to export'); return; }
  const rows = [['sim','method','winnerCandidateIndex','winnerCandidateLabel']];
  const candidateLabels = Array.from(new Set(results.flatMap(r => r.candidateLabels))).pop() || [];
  results.forEach(r => {
    rows.push([r.sim, r.method, r.winner, `Candidate ${r.winner+1}`]);
  });
  const csv = rows.map(r => r.map(v => `"${String(v).replace(/"/g,'""')}"`).join(',')).join('\n');
  const blob = new Blob([csv], {type: 'text/csv;charset=utf-8;'});
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = `voting-sim-${Date.now()}.csv`;
  a.click();
  URL.revokeObjectURL(url);
}

document.getElementById('exportCsvBtn').addEventListener('click', exportCSV);

document.getElementById('runBtn').addEventListener('click', async () => {
  // disable UI during run
  const runBtn = document.getElementById('runBtn');
  runBtn.disabled = true;
  const exportBtn = document.getElementById('exportCsvBtn'); exportBtn.disabled = true;

  // gather params
  const numVoters = Math.max(1, parseInt(document.getElementById('numVoters').value) || 100);
  const numCandidates = Math.max(2, parseInt(document.getElementById('numCandidates').value) || 4);
  const numSimulations = Math.max(1, parseInt(document.getElementById('numSimulations').value) || 20);
  const voterModel = document.getElementById('voterModel').value;
  const seedInput = document.getElementById('seed').value.trim();
  const approvalK = Math.max(1, Math.min(numCandidates, parseInt(document.getElementById('approvalK').value) || 1));

  const rng = seededRNG(seedInput || String(Date.now())); // seeded for reproducibility if seed given

  // prepare counters
  const winCounts = {};
  methods.forEach(m => winCounts[m.id] = new Array(numCandidates).fill(0));
  results.length = 0; // clear results list
  document.getElementById('results-list').innerHTML = '';

  updateProgress(0, 'Starting simulations...');
  const chunkSize = 1; // process per-simulation; adjust or use worker for big loads

  for (let s = 0; s < numSimulations; s++) {
    // if seed is provided, we want reproducibility for each simulation; use rng differently per sim
    // generate ballots
    const ballots = generateBallots(numVoters, numCandidates, voterModel, rng);
    const candidateLabels = Array.from({length: numCandidates}, (_,i) => i+1);

    // evaluate all methods
    for (const m of methods) {
      const winner = m.fn(ballots, {approvalK});
      const winnerDisplay = (winner === null || winner === undefined) ? 'Tie/None' : `Candidate ${winner+1}`;
      winCounts[m.id][(winner===null?0:winner)] = winCounts[m.id][(winner===null?0:winner)] + (winner===null?0:1);
      results.push({ sim: s+1, method: m.id, winner: (winner===null? -1 : winner), candidateLabels });
      // append to list
      const li = document.createElement('li');
      li.textContent = `Sim ${s+1} — ${m.id}: ${winnerDisplay}`;
      document.getElementById('results-list').appendChild(li);
    }

    // update progress & UI every iteration
    updateProgress(Math.round(((s+1)/numSimulations)*100), `Running ${s+1} / ${numSimulations}`);
    // let the UI breathe
    await new Promise(res => setTimeout(res, 0));
  }

  // summarize — compute per-method summary text
  const summaryParts = methods.map(m => {
    const arr = winCounts[m.id];
    const totalWins = arr.reduce((a,b)=>a+b,0);
    return `${m.id}: ${totalWins} wins (per-candidate: ${arr.map((v,i)=>`C${i+1}=${v}`).join(', ')})`;
  });
  document.getElementById('summary-content').innerHTML = summaryParts.map(p => `<div class="small">${p}</div>`).join('');

  // build table and chart
  renderTable(winCounts, Array.from({length:numCandidates}, (_,i) => i+1));
  renderChart(winCounts, Array.from({length:numCandidates}, (_,i) => i+1));

  updateProgress(100, 'Done');
  runBtn.disabled = false;
  exportBtn.disabled = false;
});

/* Initialize */
resetUI();
updateProgress(0, 'Idle');

</script>
</body>
</html>
